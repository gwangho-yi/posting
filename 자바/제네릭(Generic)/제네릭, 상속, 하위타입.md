어떤 타입이 다른 타입에 호환된다면 할당이 가능하다.
```java
Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger;
```
`Integer`는 `Object`의 하위이기 때문에 할당할 수 있다.
객체지향 용어에서는 이를 **"is a"** 관계라고 부른다. `Interger`는 `Object`의 한 종류 (`Interger` is a kind of `Object`)이기 때문에 할당 가능하다. 또한 `Interger`는 `Number`의 의 한 종류 이기도 하다.

``` java
public void someMethod(Number n) { /* ... */ }

someMethod(new Integer(10)); 
someMethod(new Double(10.1)); 
```

제네릭에서도 동일하다. `Number` 타입을 인자로 넘겨 제네릭 타입을 호출할 때, `add` 메서드는 `Number`에 호환되는 타입들을 인자로 허락한다.
```java
Box<Number> box = new Box<Number>();
box.add(new Integer(10)); 
box.add(new Double(10.1));
```

그렇다면 아래 메서드는 어떨까?
```java
public void boxTest(Box<Number> n) {}
```

`boxTest`는 `Box<Integer>` , `Box<Double>`을 인자로 받을 수 있을까? 정답은 **"No"** 다 왜냐하면, 둘 다 `Box<Number>` 의 하위타입(Sub Type)이 아니기 때문이다. 제네릭을 이해하는데 있어 쉽게 오해할 수 있는 부분이지만, 반드시 학습해야할 중요한 개념이다.

```mermaid
flowchart TB
    subgraph left["클래스 상속 관계"]
        direction BT
        Integer --> Number
    end

    subgraph right["제네릭은 이렇게 안 됨 ❌"]
        direction BT
        BoxInteger1["Box&lt;Integer&gt;"] -.-x BoxNumber1["Box&lt;Number&gt;"]
    end

    subgraph bottom["실제 제네릭 상속 관계"]
        direction BT
        BoxNumber2["Box&lt;Number&gt;"] --> Object
        BoxInteger2["Box&lt;Integer&gt;"] --> Object
    end
```

### 제네릭 클래스와 서브타이핑(Generic Classes and Subtyping)
